package com.giorgioaresu.batchrenamer;

import android.net.Uri;
import android.os.Parcel;
import android.os.Parcelable;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import eu.chainfire.libsuperuser.Shell;

public class File implements Parcelable {
    Uri fileUri;
    String oldName;
    String newName;
    RENAME status;

    /**
     * Map used to deal with conflicting file names
     */
    static Map<String, Integer> files;

    public enum RENAME {
        SUCCESSFUL(0),
        FAILED_GENERIC(3),
        FAILED_NOSOURCEFILE(4),
        FAILED_PERMISSION(5),
        FAILED_DESTINATIONEXISTS(6);

        private final int id;

        private RENAME(int id) {
            this.id = id;
        }

        public int getID() {
            return id;
        }

        public boolean compare(int i) {
            return id == i;
        }

        public static RENAME getValue(int _id) {
            RENAME[] As = RENAME.values();
            for (int i = 0; i < As.length; i++) {
                if (As[i].compare(_id))
                    return As[i];
            }
            // Value not recognized. Just return generic error.
            return FAILED_GENERIC;
        }
    }

    private File(Parcel in) {
        fileUri = Uri.CREATOR.createFromParcel(in);
        oldName = in.readString();
        newName = in.readString();
        status = RENAME.getValue(in.readInt());
    }

    public File(Uri uri) {
        fileUri = uri;
        oldName = fileUri.getLastPathSegment();
        newName = oldName;
        status = RENAME.SUCCESSFUL;
    }

    /**
     * Initialize for conflict free filenames
     */
    public static void prepareForConflictFreeName() {
        files = new HashMap<String, Integer>();
    }

    /**
     * Compute filename safe for conflicts
     *
     * @param name proposed name of file
     * @return name for file with suffix if needed
     */
    public static String conflictFreeName(String name) {
        Integer a = files.get(name.toLowerCase());
        String newName = name;
        if (a == null) {
            a = 1;
        } else {
            // Find the last dot in the name
            int lastIndexOfDot = name.lastIndexOf('.');

            String fName, fExt;

            if (lastIndexOfDot == -1) {
                fName = name;
                fExt = null;
            } else {
                // We have a filename composed of name + extension, so we need
                // to discern them
                fName = name.substring(0, lastIndexOfDot);
                fExt = "." + name.substring(lastIndexOfDot + 1);
            }
            newName = String.format("%s (%d)%s", fName, a, (fExt != null) ? fExt : "");
        }
        files.put(name.toLowerCase(), ++a);
        return newName;
    }

    public RENAME rename() {
        // TODO: support different folder generated by rename (ie. Add "lorem/ipsum" to file")
        java.io.File dir = new java.io.File(fileUri.getPath().substring(0, fileUri.getPath().lastIndexOf(java.io.File.separator)));
        java.io.File from = new java.io.File(dir, oldName);
        java.io.File to = new java.io.File(dir, newName);

        if (!dir.canRead() && !dir.canWrite() && !from.exists() && !to.exists()) {
            // Every check fails, it's highly probable we're required to use superuser permissions
            // Try to obtain root access
            Debug.log("Trying to obtain root access");
            try {
                if (SuHelper.isSuAvailable()) {
                    String shell = "sh";
                    String scriptPath = MainActivity.scriptFile.getCanonicalPath();
                    String command = String.format("%s \"%s\" \"%s\" \"%s\"",
                            shell,
                            scriptPath,
                            from.getCanonicalPath(),
                            to.getCanonicalPath());
                    List<String> result = Shell.SU.run(command);
                    if (result.size() > 0) {
                        status = RENAME.getValue(Integer.valueOf(result.get(0)));
                    }
                } else {
                    Debug.logError("su not available");
                }
            } catch (Exception e) {
                Debug.logError("Error obtaining root access", e);
            }
            status = RENAME.FAILED_PERMISSION;
        } else if (!from.exists()) {
            // Source file doesn't exist
            status = RENAME.FAILED_NOSOURCEFILE;
        } else if (!(from.canRead() && dir.canWrite())) {
            // Can't read source file or can't write on directory
            status = RENAME.FAILED_PERMISSION;
        } else if (to.exists()) {
            // Destination file already exists
            status = RENAME.FAILED_DESTINATIONEXISTS;
        } else if (from.renameTo(to)) {
            // Rename successful
            status = RENAME.SUCCESSFUL;
        } else {
            // Every check succeeded but rename failed
            status = RENAME.FAILED_GENERIC;
        }

        return status;
    }

    public static final Parcelable.Creator<File> CREATOR
            = new Parcelable.Creator<File>() {
        public File createFromParcel(Parcel in) {
            return new File(in);
        }

        public File[] newArray(int size) {
            return new File[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel parcel, int i) {
        Uri.writeToParcel(parcel, fileUri);
        parcel.writeString(oldName);
        parcel.writeString(newName);
        parcel.writeInt(status.getID());
    }
}
